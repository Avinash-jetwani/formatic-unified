name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18' # Ensure this matches your EC2 environment
        cache: 'npm' # Cache npm dependencies

    - name: Build Backend
      working-directory: ./backend
      run: |
        npm ci
        npx prisma generate # Generate Prisma client before build
        npm run build
        # Verify build succeeded
        if [ ! -d "dist" ]; then
          echo "ERROR: Backend build failed - dist directory not found"
          exit 1
        fi
        # Remove dev dependencies node_modules before packaging
        rm -rf node_modules
        npm ci --omit=dev # Install only production dependencies
        # Create a tarball of the backend build and production node_modules
        # CRITICAL: Excluded .env from this tarball. It MUST be managed on the server.
        tar -czf backend-build.tar.gz dist prisma node_modules package.json package-lock.json
        # Verify tarball was created
        if [ ! -f "backend-build.tar.gz" ]; then
          echo "ERROR: Failed to create backend-build.tar.gz"
          exit 1
        fi
        echo "âœ… Backend build completed successfully"
        ls -la backend-build.tar.gz

    - name: Build Frontend
      working-directory: ./frontend
      env:
        NEXT_PUBLIC_API_URL: ${{ secrets.API_URL || 'https://www.datizmo.com' }}
        NEXTAUTH_URL: ${{ secrets.FRONTEND_URL || 'https://www.datizmo.com' }}
      run: |
        npm ci
        npx prisma generate # Generate Prisma client before build
        
        # Create production environment file
        cat > .env.production << EOF
        NODE_ENV=production
        NEXT_PUBLIC_API_URL=${NEXTAUTH_URL}
        NEXTAUTH_URL=${NEXTAUTH_URL}
        NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET || 'change-this-in-production' }}
        NEXT_PUBLIC_S3_PUBLIC_URL=https://formatic-uploads-dev.s3.amazonaws.com
        NEXT_PUBLIC_AWS_REGION=eu-west-2
        NEXT_PUBLIC_S3_BUCKET_NAME=formatic-uploads-dev
        EOF
        
        npm run build
        # Verify build succeeded
        if [ ! -d ".next" ]; then
          echo "ERROR: Frontend build failed - .next directory not found"
          exit 1
        fi
        # Remove dev dependencies node_modules before packaging
        rm -rf node_modules
        npm ci --omit=dev # Install only production dependencies
        # Create a tarball of the frontend build and production node_modules
        # The .next directory contains the built static assets in .next/static
        # The public directory is at the root of the frontend workspace (if it exists)
        tar -czf frontend-build.tar.gz .next node_modules package.json package-lock.json next.config.js .env.production # Add other necessary files
        # Verify tarball was created
        if [ ! -f "frontend-build.tar.gz" ]; then
          echo "ERROR: Failed to create frontend-build.tar.gz"
          exit 1
        fi
        echo "âœ… Frontend build completed successfully"
        ls -la frontend-build.tar.gz

    - name: Copy Backend Build to EC2
      uses: appleboy/scp-action@master
      with:
        host: ${{ secrets.SERVER_IP }}
        username: ec2-user # Updated username
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        source: "backend/backend-build.tar.gz"
        target: "/home/ec2-user/formatic-unified/"
        strip_components: 1

    - name: Copy Frontend Build to EC2
      uses: appleboy/scp-action@master
      with:
        host: ${{ secrets.SERVER_IP }}
        username: ec2-user # Updated username
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        source: "frontend/frontend-build.tar.gz"
        target: "/home/ec2-user/formatic-unified/"
        strip_components: 1

    - name: Copy Password Reset Script to EC2
      uses: appleboy/scp-action@master
      with:
        host: ${{ secrets.SERVER_IP }}
        username: ec2-user
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        source: "backend/scripts/reset-user-passwords.js"
        target: "/home/ec2-user/formatic-unified/backend/"
        strip_components: 2

        
    - name: Execute Deployment Commands on EC2
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.SERVER_IP }}
        username: ec2-user # Updated username
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        script: |
          set -e
          APP_DIR="/home/ec2-user/formatic-unified"
          BACKEND_DIR="$APP_DIR/backend"
          FRONTEND_DIR="$APP_DIR/frontend"
          NVM_DIR="/home/ec2-user/.nvm"
          DOMAIN="${{ secrets.DOMAIN || 'datizmo.com' }}"
          API_URL="${{ secrets.API_URL || 'https://www.datizmo.com/api' }}"
          FRONTEND_URL="${{ secrets.FRONTEND_URL || 'https://www.datizmo.com' }}"

          echo "=== Starting deployment on server as $(whoami) ==="
          echo "Domain: $DOMAIN"
          echo "API URL: $API_URL"
          echo "Frontend URL: $FRONTEND_URL"
          
          echo "=== Sourcing NVM for PM2 and Node commands ==="
          export NVM_DIR="$NVM_DIR"
          [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"  # This loads nvm
          [ -s "$NVM_DIR/bash_completion" ] && . "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

          echo "Node version: $(node -v)"
          echo "NPM version: $(npm -v)"
          
          # Check if PM2 is installed, install if not
          if ! command -v pm2 &> /dev/null; then
            echo "PM2 not found, installing globally..."
            npm install -g pm2
          fi
          echo "PM2 version: $(pm2 --version)"

          echo "=== Stopping existing services ==="
          pm2 stop all || echo "No PM2 processes running"

          echo "=== Checking for build artifacts in $APP_DIR ==="
          cd $APP_DIR
          ls -la *.tar.gz || echo "No .tar.gz files found in $APP_DIR"

          echo "=== Moving and extracting Backend Artifacts ==="
          if [ -f "$APP_DIR/backend-build.tar.gz" ]; then
            mv "$APP_DIR/backend-build.tar.gz" "$BACKEND_DIR/"
            cd $BACKEND_DIR
            echo "Current backend directory: $(pwd)"
            echo "Extracting backend build..."
            tar -xzf backend-build.tar.gz
            rm backend-build.tar.gz # Clean up tarball
            echo "Backend build extracted successfully."
          else
            echo "ERROR: backend-build.tar.gz not found in $APP_DIR! Deployment halted."
            exit 1
          fi
          
          echo "=== Moving and extracting Frontend Artifacts ==="
          if [ -f "$APP_DIR/frontend-build.tar.gz" ]; then
            mv "$APP_DIR/frontend-build.tar.gz" "$FRONTEND_DIR/"
            cd $FRONTEND_DIR
            echo "Current frontend directory: $(pwd)"
            echo "Extracting frontend build..."
            tar -xzf frontend-build.tar.gz
            rm frontend-build.tar.gz # Clean up tarball
            echo "Frontend build extracted successfully."
          else
            echo "ERROR: frontend-build.tar.gz not found in $APP_DIR! Deployment halted."
            exit 1
          fi

          echo "=== Updating base repository code ==="
          cd $APP_DIR
          echo "Current directory: $(pwd)"
          git fetch origin main # Fetch latest changes
          git reset --hard origin/main # Force update to latest, discarding local changes for non-artifact files

          echo "=== Ensuring backend .env file exists ==="
          cd $BACKEND_DIR # Change back to backend dir for .env check and migrations
          if [ ! -f .env ]; then
            echo "CRITICAL WARNING: .env file not found in $BACKEND_DIR. Prisma migrate and backend start will likely fail!"
            echo "Please ensure .env file is created on the server with proper database configuration."
            exit 1
          else
            echo ".env file found in backend directory."
          fi

          echo "=== Running Prisma migrations ==="
          npx prisma migrate deploy || { echo "Prisma migration failed"; exit 1; }

          echo "=== Regenerating Prisma client ==="
          npx prisma generate || { echo "Prisma generation failed"; exit 1; }

          echo "=== Running password reset script ==="
          if [ -f "scripts/reset-user-passwords.js" ]; then
            echo "Running password reset for admin and test users..."
            node scripts/reset-user-passwords.js || echo "Password reset script failed, continuing deployment..."
          else
            echo "Password reset script not found, skipping..."
          fi

          echo "=== Ensuring frontend .env.production file exists ==="
          cd $FRONTEND_DIR # Change to frontend dir for .env check
          if [ ! -f .env.production ]; then
            echo "WARNING: .env.production file not found in $FRONTEND_DIR."
            echo "Creating basic .env.production file..."
            cat > .env.production << EOF
          NODE_ENV=production
          NEXT_PUBLIC_API_URL=$FRONTEND_URL
          NEXTAUTH_URL=$FRONTEND_URL
          NEXTAUTH_SECRET=your-secret-key-here
          NEXT_PUBLIC_S3_PUBLIC_URL=https://formatic-uploads-dev.s3.amazonaws.com
          NEXT_PUBLIC_AWS_REGION=eu-west-2
          NEXT_PUBLIC_S3_BUCKET_NAME=formatic-uploads-dev
          EOF
          else
            echo ".env.production file found in frontend directory."
            # Update existing file with correct URLs
            sed -i "s|NEXT_PUBLIC_API_URL=.*|NEXT_PUBLIC_API_URL=$FRONTEND_URL|g" .env.production
            sed -i "s|NEXTAUTH_URL=.*|NEXTAUTH_URL=$FRONTEND_URL|g" .env.production
          fi

          echo "=== Starting services with PM2 ==="
          cd $APP_DIR # PM2 ecosystem file is likely in APP_DIR
          if [ -f "ecosystem.config.js" ]; then
            echo "Using PM2 ecosystem file to manage services..."
            # Delete existing processes to ensure clean start
            pm2 delete all || echo "No existing processes to delete"
            # Start fresh with ecosystem file
            pm2 start ecosystem.config.js --env production
            echo "Waiting for services to stabilize..."
            sleep 10
          else
            echo "PM2 ecosystem file not found. Starting services directly..."
            # Delete existing processes
            pm2 delete all || echo "No existing processes to delete"
            # Start backend with correct path
            if [ -f "$BACKEND_DIR/dist/src/main.js" ]; then
              pm2 start $BACKEND_DIR/dist/src/main.js --name backend --cwd $BACKEND_DIR
            else
              pm2 start $BACKEND_DIR/dist/main.js --name backend --cwd $BACKEND_DIR
            fi
            # Start frontend  
            pm2 start npm --name frontend -- run start --cwd $FRONTEND_DIR
          fi
          
          echo "=== Saving PM2 process list ==="
          pm2 save

          echo "=== Checking PM2 status ==="
          pm2 status

          echo "=== Setting up SSL certificates ==="
          # Remove any existing certbot installation and SSL certificates
          sudo systemctl stop nginx || echo "Nginx not running"
          
          # Clean up existing certbot
          sudo yum remove -y certbot python3-certbot-nginx || echo "Certbot not installed"
          sudo rm -rf /etc/letsencrypt /var/lib/letsencrypt /var/log/letsencrypt || echo "No existing certbot files"
          sudo rm -f /etc/ssl/certs/$DOMAIN.* /etc/ssl/private/$DOMAIN.* || echo "No existing SSL files"
          
          # Install EPEL repository (needed for certbot)
          sudo yum install -y epel-release
          
          # Install certbot and nginx plugin
          sudo yum install -y certbot python3-certbot-nginx
          
          # Verify certbot installation
          sudo certbot --version
          
          echo "=== Configuring Nginx for HTTP first (for certbot verification) ==="
          sudo tee /etc/nginx/conf.d/formatic.conf << EOF
          server {
              listen 80;
              server_name $DOMAIN www.$DOMAIN;
              
              # Allow certbot to serve its verification files
              location /.well-known/acme-challenge/ {
                  root /var/www/html;
                  allow all;
              }
              
              # API routes
              location /api/ {
                  proxy_pass http://127.0.0.1:3001;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade \$http_upgrade;
                  proxy_set_header Connection 'upgrade';
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
                  proxy_cache_bypass \$http_upgrade;
              }
              
              # Next.js static files
              location /_next/static {
                  proxy_pass http://127.0.0.1:3000;
                  proxy_cache_valid 200 1y;
                  add_header Cache-Control "public, immutable";
                  expires 1y;
              }
              
              # Static assets
              location ~* \.(ico|css|js|gif|jpeg|jpg|png|svg|woff|woff2|ttf|eot)$ {
                  proxy_pass http://127.0.0.1:3000;
                  expires 1y;
                  add_header Cache-Control "public, immutable";
              }
              
              # All other routes
              location / {
                  proxy_pass http://127.0.0.1:3000;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade \$http_upgrade;
                  proxy_set_header Connection 'upgrade';
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
                  proxy_cache_bypass \$http_upgrade;
              }
          }
          EOF
          
          echo "=== Creating web root directory for certbot ==="
          sudo mkdir -p /var/www/html
          sudo chown -R nginx:nginx /var/www/html
          
          echo "=== Testing and Starting Nginx ==="
          sudo nginx -t
          if [ $? -eq 0 ]; then
            echo "âœ… Nginx config valid - starting nginx"
            sudo systemctl enable nginx
            sudo systemctl restart nginx
            sleep 5
            echo "âœ… Nginx started successfully"
          else
            echo "âŒ Nginx config invalid"
            exit 1
          fi
          
          echo "=== Obtaining SSL certificates with Let's Encrypt ==="
          # Stop nginx temporarily for standalone mode
          sudo systemctl stop nginx
          
          # Get SSL certificate using standalone mode (more reliable)
          sudo certbot certonly --standalone \
            --non-interactive \
            --agree-tos \
            --email admin@$DOMAIN \
            --domains $DOMAIN,www.$DOMAIN \
            --expand \
            --renew-by-default
          
          if [ $? -eq 0 ]; then
            echo "âœ… SSL certificates obtained successfully"
            
            echo "=== Updating Nginx Configuration with SSL ==="
            sudo tee /etc/nginx/conf.d/formatic.conf << EOF
          server {
              listen 80;
              server_name $DOMAIN www.$DOMAIN;
              
              # Redirect all HTTP traffic to HTTPS
              return 301 https://\$server_name\$request_uri;
          }
          
          server {
              listen 443 ssl http2;
              server_name $DOMAIN www.$DOMAIN;
              
              # SSL configuration using Let's Encrypt certificates
              ssl_certificate /etc/letsencrypt/live/$DOMAIN/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/$DOMAIN/privkey.pem;
              
              # Modern SSL configuration
              ssl_protocols TLSv1.2 TLSv1.3;
              ssl_prefer_server_ciphers off;
              ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
              
              # HSTS (optional but recommended)
              add_header Strict-Transport-Security "max-age=63072000" always;
              
              # Security headers
              add_header X-Frame-Options "SAMEORIGIN" always;
              add_header X-XSS-Protection "1; mode=block" always;
              add_header X-Content-Type-Options "nosniff" always;
              add_header Referrer-Policy "no-referrer-when-downgrade" always;
              
              # API routes
              location /api/ {
                  proxy_pass http://127.0.0.1:3001;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade \$http_upgrade;
                  proxy_set_header Connection 'upgrade';
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
                  proxy_cache_bypass \$http_upgrade;
              }
              
              # Next.js static files
              location /_next/static {
                  proxy_pass http://127.0.0.1:3000;
                  proxy_cache_valid 200 1y;
                  add_header Cache-Control "public, immutable";
                  expires 1y;
              }
              
              # Static assets
              location ~* \.(ico|css|js|gif|jpeg|jpg|png|svg|woff|woff2|ttf|eot)$ {
                  proxy_pass http://127.0.0.1:3000;
                  expires 1y;
                  add_header Cache-Control "public, immutable";
              }
              
              # All other routes
              location / {
                  proxy_pass http://127.0.0.1:3000;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade \$http_upgrade;
                  proxy_set_header Connection 'upgrade';
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
                  proxy_cache_bypass \$http_upgrade;
              }
          }
          EOF
            
            echo "=== Setting up automatic SSL renewal ==="
            # Test renewal
            sudo certbot renew --dry-run
            
            # Set up cron job for automatic renewal
            echo "0 3 * * * root certbot renew --quiet && systemctl reload nginx" | sudo tee -a /etc/crontab
            
          else
            echo "âŒ Failed to obtain SSL certificates"
            echo "Setting up with self-signed certificates as fallback..."
            
            # Create SSL directory if it doesn't exist
            sudo mkdir -p /etc/ssl/certs /etc/ssl/private
            
            # Generate self-signed certificate as fallback
            sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
              -keyout /etc/ssl/private/$DOMAIN.key \
              -out /etc/ssl/certs/$DOMAIN.crt \
              -subj "/C=US/ST=State/L=City/O=Organization/OU=OrgUnit/CN=$DOMAIN"
            
            echo "=== Updating Nginx Configuration with Self-Signed SSL ==="
            sudo tee /etc/nginx/conf.d/formatic.conf << EOF
          server {
              listen 80;
              server_name $DOMAIN www.$DOMAIN;
              return 301 https://\$server_name\$request_uri;
          }
          
          server {
              listen 443 ssl;
              server_name $DOMAIN www.$DOMAIN;
              
              # SSL configuration with self-signed certificates
              ssl_certificate /etc/ssl/certs/$DOMAIN.crt;
              ssl_certificate_key /etc/ssl/private/$DOMAIN.key;
              ssl_protocols TLSv1.2 TLSv1.3;
              ssl_ciphers HIGH:!aNULL:!MD5;
              ssl_prefer_server_ciphers on;
              
              # Security headers
              add_header X-Frame-Options "SAMEORIGIN" always;
              add_header X-XSS-Protection "1; mode=block" always;
              add_header X-Content-Type-Options "nosniff" always;
              
              # API routes
              location /api/ {
                  proxy_pass http://127.0.0.1:3001;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade \$http_upgrade;
                  proxy_set_header Connection 'upgrade';
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
                  proxy_cache_bypass \$http_upgrade;
              }
              
              # Next.js static files
              location /_next/static {
                  proxy_pass http://127.0.0.1:3000;
                  proxy_cache_valid 200 1y;
                  add_header Cache-Control "public, immutable";
                  expires 1y;
              }
              
              # Static assets
              location ~* \.(ico|css|js|gif|jpeg|jpg|png|svg|woff|woff2|ttf|eot)$ {
                  proxy_pass http://127.0.0.1:3000;
                  expires 1y;
                  add_header Cache-Control "public, immutable";
              }
              
              # All other routes
              location / {
                  proxy_pass http://127.0.0.1:3000;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade \$http_upgrade;
                  proxy_set_header Connection 'upgrade';
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
                  proxy_cache_bypass \$http_upgrade;
              }
                      }
            EOF
            fi
          
          echo "=== Testing and Starting Nginx ==="
          sudo nginx -t
          if [ $? -eq 0 ]; then
            echo "âœ… Nginx config valid - starting/restarting nginx"
            sudo systemctl enable nginx
            sudo systemctl restart nginx
            sleep 5
            echo "âœ… Nginx started successfully"
          else
            echo "âŒ Nginx config invalid"
            exit 1
          fi

          echo "=== Final health checks ==="
          sleep 10
          
          echo "Testing HTTP redirect..."
          curl -s --head http://$DOMAIN | grep -E 'HTTP|301|302' || echo "HTTP redirect test failed"
          
          echo "Testing HTTPS access..."
          if [ -f "/etc/letsencrypt/live/$DOMAIN/fullchain.pem" ]; then
            echo "Using Let's Encrypt certificate"
            curl -s --head https://$DOMAIN | grep -E 'HTTP|200' || echo "HTTPS test failed"
          else
            echo "Using self-signed certificate (will show browser warning)"
            curl -s -k --head https://$DOMAIN | grep -E 'HTTP|200' || echo "HTTPS test failed"
          fi
          
          echo "Testing API endpoint..."
          curl -s -k --head https://$DOMAIN/api/users | grep -E 'HTTP|401|403|200' || echo "API test failed"
          
          echo "=== SSL Certificate Status ==="
          if [ -f "/etc/letsencrypt/live/$DOMAIN/fullchain.pem" ]; then
            echo "âœ… Let's Encrypt SSL certificate installed successfully!"
            sudo certbot certificates
          else
            echo "âš ï¸  Self-signed SSL certificate installed (browser will show warning)"
            echo "Let's Encrypt certificate installation failed - check logs above"
          fi
          
          echo "=== Deployment completed! ==="
          echo "ðŸŒ Your app should be available at: https://$DOMAIN"
          if [ ! -f "/etc/letsencrypt/live/$DOMAIN/fullchain.pem" ]; then
            echo "âš ï¸  Note: Browser will show security warning due to self-signed certificate"
          fi
          echo ""
          echo "ðŸ“‹ USER CREDENTIALS RESET:"
          echo "========================="
          echo "Email: admin@formatic.com"
          echo "Password: NewAdmin2024!"
          echo "-------------------------"
          echo "Email: john@doe.com"
          echo "Password: JohnDoe2024!"
          echo "========================="
