#!/bin/bash
set -e

# Colors for better readability
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
RED='\\033[0;31m'
NC='\\033[0m' # No Color

# Log function
log() {
  echo -e "${GREEN}[$(date '+%Y-%m-%d %H:%M:%S')] $1${NC}"
}

error() {
  echo -e "${RED}[ERROR] $1${NC}" >&2
}

warn() {
  echo -e "${YELLOW}[WARNING] $1${NC}"
}

# --- Configuration - Adjust these variables as needed ---
APP_USER="ec2-user" # The user that will own the application files and run pm2
APP_DIR="/home/$APP_USER/formatic-unified" # Main application directory
REPO_URL="https://github.com/Avinash-jetwani/formatic-unified.git" # User's repository URL
DOMAIN_NAME="datizmo.com" # User's domain name
ADMIN_EMAIL="jetwaniavinash@gmail.com" # User's email for SSL certificate registration

# Ensure NEXTAUTH_URL and other sensitive env vars are set appropriately later
# These are placeholders - USER MUST FILL THESE ON THE SERVER
DATABASE_URL_PLACEHOLDER="postgresql://postgres:immortal1497db@formatic-dev-db.c7edc3pems97.eu-west-2.rds.amazonaws.com:5432/formatic-dev-db"
JWT_SECRET_PLACEHOLDER="p4t7w!z%C*F-JaNdRgUjXn2r5u8x/A?D(G+KbPeShVmYq3s6v9y$B&E)H@McQfTj" # GENERATED - Use this in backend .env
NEXTAUTH_SECRET_PLACEHOLDER="kZp7x!A%D*G-KaPdSgVkYp3s6v9y$B&E(H+MbQeThWmZq4t7w!z%C*F-JaNdRgUj" # GENERATED - Use this in frontend .env.production (and backend if shared)
AWS_ACCESS_KEY_ID_PLACEHOLDER="AKIAQ7KIB76C33G75FOM_EnsureThisIsCorrect_Or_Use_IAM_Role"
AWS_SECRET_ACCESS_KEY_PLACEHOLDER="3B7GDaiWrSDA3BVQh2A9JWj65yLuR3TtIa_gnFIO_EnsureThisIsCorrect_Or_Use_IAM_Role"
AWS_S3_BUCKET_PLACEHOLDER="formatic-uploads-dev" # Updated S3 bucket name
SMTP_HOST_PLACEHOLDER="your_smtp_host"
SMTP_PORT_PLACEHOLDER="587"
SMTP_USER_PLACEHOLDER="your_smtp_user"
SMTP_PASS_PLACEHOLDER="your_smtp_password"
EMAIL_FROM_PLACEHOLDER="noreply@$DOMAIN_NAME"


# --- Script Start ---
log "Starting Initial Server Setup for Datizmo (User: $APP_USER)..."

if [ "$(id -u)" != "0" ]; then
  error "This script must be run as root. Please use sudo."
  exit 1
fi

# 1. System Update and Essential Packages
log "Updating system packages and installing essential tools..."
# Commands might differ slightly for Amazon Linux (yum vs apt-get)
# Assuming an Amazon Linux 2 environment based on 'ec2-user'
if command -v yum &> /dev/null; then
    yum update -y
    yum install -y curl wget git unzip nginx # ufw is not typically used on Amazon Linux, Security Groups are preferred
elif command -v apt-get &> /dev/null; then
    apt-get update
    apt-get upgrade -y
    apt-get install -y curl wget git unzip nginx ufw
else
    error "Cannot determine package manager (yum or apt-get). Exiting."
    exit 1
fi

# 2. Install Node.js and PM2
log "Installing Node.js v18.x and PM2..."
if ! command -v node &> /dev/null; then
  # For Amazon Linux, NodeSource setup might differ slightly. Using nvm is often more robust.
  log "Installing nvm (Node Version Manager)..."
  sudo -u $APP_USER curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | sudo -u $APP_USER bash
  sudo -u $APP_USER sh -c ". /home/$APP_USER/.nvm/nvm.sh && nvm install 18 && nvm alias default 18 && nvm use default"
  log "NVM and Node.js 18 installed for user $APP_USER."
  sudo -u $APP_USER sh -c ". /home/$APP_USER/.nvm/nvm.sh && npm install -g pm2"
  log "PM2 installed globally for Node.js 18 managed by NVM."
else
  log "Node.js version $(node -v) already installed."
  if ! sudo -u $APP_USER sh -c ". /home/$APP_USER/.nvm/nvm.sh && command -v pm2" &> /dev/null; then
    sudo -u $APP_USER sh -c ". /home/$APP_USER/.nvm/nvm.sh && npm install -g pm2"
    log "PM2 installed."
  else
    log "PM2 already installed."
  fi
fi

# Ensure pm2 can start on boot
# The command generated by `pm2 startup` needs to be run as root.
PM2_STARTUP_CMD=$(sudo -u $APP_USER sh -c ". /home/$APP_USER/.nvm/nvm.sh && pm2 startup systemd -u $APP_USER --hp /home/$APP_USER | tail -n 1")
if [[ -n "$PM2_STARTUP_CMD" && "$PM2_STARTUP_CMD" != *"[PM2] Command not found"* ]]; then
  log "Running PM2 startup command: $PM2_STARTUP_CMD"
  eval "$PM2_STARTUP_CMD"
  log "Configured PM2 to start on boot for user $APP_USER."
else
  warn "Could not automatically determine PM2 startup command. Please run 'sudo -u $APP_USER pm2 startup' and execute the outputted command manually."
fi

# 3. Configure Firewall (Security Groups on EC2 are primary)
# For Amazon Linux, UFW is not standard. Firewall rules are managed via EC2 Security Groups.
log "Firewall configuration on EC2 is primarily managed by Security Groups."
log "Ensure your Security Group allows inbound traffic on Port 22 (SSH), 80 (HTTP), 443 (HTTPS)."
if command -v ufw &> /dev/null; then # If ufw was installed (e.g. on Ubuntu base for some reason)
    log "Configuring UFW (if present)..."
    ufw default deny incoming
    ufw default allow outgoing
    ufw allow ssh
    ufw allow http
    ufw allow https
    ufw --force enable
    log "UFW configured and enabled."
fi

# 4. Application Directory (already created user 'ec2-user' exists)
log "Ensuring application directory exists: $APP_DIR"
mkdir -p $APP_DIR
chown -R $APP_USER:$APP_USER $APP_DIR
chmod -R 755 $APP_DIR # User rwx, group rx, others rx

# 5. Clone Repository
log "Cloning repository from $REPO_URL into $APP_DIR..."
if [ -d "$APP_DIR/.git" ]; then
  warn "Repository already exists in $APP_DIR. Performing a git pull as $APP_USER instead of clone."
  sudo -u $APP_USER git -C $APP_DIR pull
else
  sudo -u $APP_USER git clone $REPO_URL $APP_DIR
  log "Repository cloned into $APP_DIR by user $APP_USER."
fi

# 6. Setup Backend .env file
log "Setting up backend .env file (placeholder) in $APP_DIR/backend/.env..."
BACKEND_DIR="$APP_DIR/backend"
BACKEND_ENV_FILE="$BACKEND_DIR/.env"
mkdir -p $BACKEND_DIR # Ensure backend directory exists
chown $APP_USER:$APP_USER $BACKEND_DIR

if [ -f "$BACKEND_ENV_FILE" ]; then
  warn "Backend .env file already exists. Contents will be preserved if possible, but ensure it has all necessary variables."
  # Optionally, append missing keys or notify user to check thoroughly.
else
  sudo -u $APP_USER touch $BACKEND_ENV_FILE
fi
# Ensure the file has the correct ownership and basic permissions before writing
chown $APP_USER:$APP_USER $BACKEND_ENV_FILE
chmod 600 $BACKEND_ENV_FILE # Restrict permissions (user rw, group none, others none)

# Write placeholders - USER MUST VERIFY/UPDATE THESE MANUALLY
sudo -u $APP_USER cat > $BACKEND_ENV_FILE <<EOL
# --- Database Configuration (MUST BE VERIFIED/UPDATED BY USER) ---
DATABASE_URL=${DATABASE_URL_PLACEHOLDER}

# --- JWT Configuration (MUST BE GENERATED & UPDATED BY USER) ---
JWT_SECRET=${JWT_SECRET_PLACEHOLDER}
JWT_EXPIRATION=1d

# --- Email Configuration (MUST BE UPDATED BY USER) ---
SMTP_HOST=${SMTP_HOST_PLACEHOLDER}
SMTP_PORT=${SMTP_PORT_PLACEHOLDER}
SMTP_USER=${SMTP_USER_PLACEHOLDER}
SMTP_PASS=${SMTP_PASS_PLACEHOLDER}
EMAIL_FROM=${EMAIL_FROM_PLACEHOLDER}

# --- S3 Configuration for File Uploads (MUST BE VERIFIED/UPDATED BY USER - CONSIDER IAM ROLES FOR EC2 INSTEAD OF HARDCODED KEYS) ---
AWS_REGION=us-east-1 # Or your preferred region
AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID_PLACEHOLDER}
AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY_PLACEHOLDER}
AWS_S3_BUCKET=${AWS_S3_BUCKET_PLACEHOLDER}

# --- Application Settings ---
NODE_ENV=production
PORT=3001 # Backend listens on this port
# FRONTEND_URL=https://$DOMAIN_NAME # If needed by backend for CORS etc.
EOL
warn "IMPORTANT: Placeholder backend .env file written to $BACKEND_ENV_FILE."
warn "YOU MUST SSH INTO THE SERVER AND MANUALLY EDIT THIS FILE with your actual production credentials (Database, JWT, Email, S3 etc.)."

# 7. Setup Frontend .env.production file
log "Setting up frontend .env.production file (placeholder) in $APP_DIR/frontend/.env.production..."
FRONTEND_DIR="$APP_DIR/frontend"
FRONTEND_ENV_FILE="$FRONTEND_DIR/.env.production"
mkdir -p $FRONTEND_DIR # Ensure frontend directory exists
chown $APP_USER:$APP_USER $FRONTEND_DIR

if [ -f "$FRONTEND_ENV_FILE" ]; then
  warn "Frontend .env.production file already exists. Contents will be preserved if possible."
else
  sudo -u $APP_USER touch $FRONTEND_ENV_FILE
fi
chown $APP_USER:$APP_USER $FRONTEND_ENV_FILE
chmod 600 $FRONTEND_ENV_FILE

sudo -u $APP_USER cat > $FRONTEND_ENV_FILE <<EOL
# --- Frontend Configuration (MUST BE VERIFIED/UPDATED BY USER) ---
NEXT_PUBLIC_API_URL=https://$DOMAIN_NAME/api
NEXTAUTH_URL=https://$DOMAIN_NAME
NEXTAUTH_SECRET=${NEXTAUTH_SECRET_PLACEHOLDER} # (MUST BE GENERATED & UPDATED BY USER - SAME AS JWT_SECRET OR A DEDICATED ONE)

# Add any other NEXT_PUBLIC_ variables your frontend needs
# NEXT_PUBLIC_SOME_CONFIG_VAR=some_value
EOL
warn "IMPORTANT: Placeholder frontend .env.production file written to $FRONTEND_ENV_FILE."
warn "YOU MUST SSH INTO THE SERVER AND MANUALLY EDIT THIS FILE (especially NEXTAUTH_SECRET)."

# 8. Install Dependencies (Initial - CI/CD will handle subsequent updates and builds)
log "Performing initial dependency installation for basic setup (as $APP_USER)..."
# Backend
if [ -f "$BACKEND_DIR/package.json" ]; then
  log "Installing backend dependencies (production only)..."
  sudo -u $APP_USER sh -c "cd $BACKEND_DIR && . /home/$APP_USER/.nvm/nvm.sh && npm ci --omit=dev"
  log "Generating Prisma client for backend..."
  sudo -u $APP_USER sh -c "cd $BACKEND_DIR && . /home/$APP_USER/.nvm/nvm.sh && npx prisma generate"
else
  warn "No package.json found in $BACKEND_DIR. Skipping backend dependency install."
fi
# Frontend
if [ -f "$FRONTEND_DIR/package.json" ]; then
  log "Installing frontend dependencies (production only)..."
  sudo -u $APP_USER sh -c "cd $FRONTEND_DIR && . /home/$APP_USER/.nvm/nvm.sh && npm ci --omit=dev"
else
  warn "No package.json found in $FRONTEND_DIR. Skipping frontend dependency install."
fi
warn "Initial builds are skipped. The CI/CD pipeline will handle application builds and provide artifacts."
warn "Initial 'npx prisma migrate deploy' will be run by the first CI/CD deployment."

# 9. Setup Nginx Configuration
log "Setting up Nginx configuration for $DOMAIN_NAME..."
# For Amazon Linux, Nginx config is often in /etc/nginx/conf.d/
NGINX_CONF_DIR="/etc/nginx/conf.d"
NGINX_CONF_FILE="$NGINX_CONF_DIR/$DOMAIN_NAME.conf"

# Create a basic Nginx configuration. Certbot will modify this for SSL.
cat > "$NGINX_CONF_FILE" <<EOL
server {
    listen 80;
    server_name $DOMAIN_NAME www.$DOMAIN_NAME;

    # Serve Let's Encrypt challenge files
    location /.well-known/acme-challenge/ {
        root /var/www/html; # Default for Amazon Linux, or use /var/www/certbot
    }

    location / {
        # This block will be updated by Certbot or later for proxying
        root /var/www/html;
        index index.html index.htm;
    }
}
EOL

# Ensure Nginx service is enabled and started before testing and reloading
log "Ensuring Nginx service is enabled and started..."
sudo systemctl enable nginx
sudo systemctl start nginx

log "Testing Nginx configuration..."
if sudo nginx -t; then
  log "Nginx configuration test successful. Reloading Nginx."
  sudo systemctl reload nginx
else
  error "Nginx configuration test failed. Please check the output above."
  # Optionally exit here if Nginx config is critical for next steps before certbot
  # exit 1
fi

# 10. Setup SSL with Certbot
log "Setting up SSL certificate using Certbot..."
# Install Certbot - EPEL repo might be needed for Amazon Linux 2
if command -v yum &> /dev/null; then
    amazon-linux-extras install epel -y
    yum install -y certbot python3-certbot-nginx # Use python3-certbot-nginx for AL2
fi

# Check if Certbot and python3-certbot-nginx are installed
if ! command -v certbot &> /dev/null || ! sudo yum list installed python3-certbot-nginx &> /dev/null; then
    log "Installing Certbot and Nginx plugin..."
    sudo yum install -y certbot python3-certbot-nginx --allowerasing
else
    log "Certbot and Nginx plugin already installed."
fi

# Ensure Nginx is running before attempting to obtain SSL certificate
log "Ensuring Nginx is running before Certbot SSL setup..."
sudo systemctl start nginx # Start Nginx if not already running (e.g., if previous reload failed and stopped it)
# Check Nginx status, optional
# sudo systemctl status nginx

if [ -d "/etc/letsencrypt/live/${DOMAIN_NAME}" ]; then
    log "Configuring Nginx to use existing SSL certificate for ${DOMAIN_NAME}..."
    # Update Nginx config to use SSL - this might be redundant if already in datizmo.conf
    # Ensure the datizmo.conf has the SSL settings and then reload
    # sudo sed -i 's|listen 80;|listen 80;\\n    listen [::]:80;|g' /etc/nginx/conf.d/datizmo.conf # Example, ensure this is idempotent or correct
    # sudo sed -i '/server_name datizmo.com;/a \\    ssl_certificate /etc/letsencrypt/live/datizmo.com/fullchain.pem;\\n    ssl_certificate_key /etc/letsencrypt/live/datizmo.com/privkey.pem;\\n    include /etc/letsencrypt/options-ssl-nginx.conf;\\n    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;' /etc/nginx/conf.d/datizmo.conf

    # The Nginx config provided earlier already includes SSL stanzas listen 443 ssl; etc.
    # So, a simple reload should be sufficient if the certs exist.
    log "Reloading Nginx to apply SSL configuration..."
    sudo systemctl reload nginx
else
    log "Obtaining SSL certificate for ${DOMAIN_NAME} using Certbot..."
    # Stop Nginx temporarily for standalone an_hook (if webroot not preferred or problematic)
    # sudo systemctl stop nginx
    # sudo certbot certonly --standalone -d "${DOMAIN_NAME}" --non-interactive --agree-tos -m "${ADMIN_EMAIL}" --test-cert # Use --test-cert for initial testing
    # sudo certbot certonly --standalone -d "${DOMAIN_NAME}" --non-interactive --agree-tos -m "${ADMIN_EMAIL}"
    
    # Using webroot plugin is generally preferred as it doesn't require stopping Nginx
    # Ensure webroot path exists and is configured in Nginx for /.well-known/acme-challenge
    # Example for datizmo.conf if not already present:
    # location /.well-known/acme-challenge/ {
    #     root /var/www/html; # Or another suitable path
    # }
    # sudo mkdir -p /var/www/html # Ensure this path exists
    # sudo certbot certonly --webroot -w /var/www/html -d "${DOMAIN_NAME}" --non-interactive --agree-tos -m "${ADMIN_EMAIL}" --test-cert # For testing
    sudo certbot --nginx -d "${DOMAIN_NAME}" --non-interactive --agree-tos -m "${ADMIN_EMAIL}" --redirect --uir # --redirect handles HTTP->HTTPS, --uir adds HSTS header.
    # Check if cert was obtained
    if [ -d "/etc/letsencrypt/live/${DOMAIN_NAME}" ]; then
        log "SSL certificate obtained successfully."
        log "Reloading Nginx to apply new SSL certificate..."
        sudo systemctl reload nginx
    else
        log "Failed to obtain SSL certificate. Check Certbot logs."
        log "Attempting to start Nginx again if it was stopped..."
        sudo systemctl start nginx # Ensure Nginx is running even if certbot failed.
    fi
fi

# 11. Setup PM2 Ecosystem File (Optional but Recommended)
ECOSYSTEM_FILE_PATH="$APP_DIR/ecosystem.config.js"
log "Creating PM2 ecosystem file at $ECOSYSTEM_FILE_PATH (as $APP_USER)..."

sudo -u $APP_USER cat > $ECOSYSTEM_FILE_PATH <<EOL
module.exports = {
  apps : [{
    name   : "frontend",
    script : "npm",
    args   : "run start", // Assumes 'start': 'next start -p 3000' in frontend/package.json
    cwd    : "$APP_DIR/frontend",
    watch  : false,
    instances: 1,
    exec_mode: 'cluster', // Or 'fork'
    env_production: {
      NODE_ENV: "production",
      PORT: 3000 // Next.js listens on this port
    }
  },{
    name   : "backend",
    script : "dist/main.js", // Path to NestJS main entry point from backend directory
    cwd    : "$APP_DIR/backend",
    watch  : false,
    instances: 1,
    exec_mode: 'cluster', // Or 'fork'
    env_production: {
      NODE_ENV: "production",
      PORT: 3001 // NestJS listens on this port (must match .env and Nginx)
    }
  }]
}
EOL
chown $APP_USER:$APP_USER $ECOSYSTEM_FILE_PATH
log "PM2 ecosystem file created. The CI/CD pipeline can use this via: sudo -u $APP_USER sh -c '. /home/$APP_USER/.nvm/nvm.sh && pm2 reload $ECOSYSTEM_FILE_PATH --env production'"

# 12. Configure sudo for deployment user ($APP_USER)
SUDOERS_FILE_PATH="/etc/sudoers.d/91-$APP_USER-deploy"
log "Configuring passwordless sudo for $APP_USER for PM2 and Nginx reload..."
# Get full path to pm2 via nvm for the APP_USER
PM2_PATH_CMD="sudo -u $APP_USER sh -c '. /home/$APP_USER/.nvm/nvm.sh && which pm2'"
PM2_FULL_PATH=$(eval $PM2_PATH_CMD)

if [ -z "$PM2_FULL_PATH" ]; then
    warn "Could not determine full path to pm2 for sudoers. Please add manually."
    PM2_FULL_PATH="/home/$APP_USER/.nvm/versions/node/$(sudo -u $APP_USER sh -c '. /home/$APP_USER/.nvm/nvm.sh && node -v')/bin/pm2" # Fallback guess
fi

cat > "$SUDOERS_FILE_PATH" <<EOL
# Allow $APP_USER to manage PM2 services and reload Nginx without a password
$APP_USER ALL=(ALL) NOPASSWD: $PM2_FULL_PATH, /bin/systemctl reload nginx
EOL
chmod 0440 "$SUDOERS_FILE_PATH" # Secure permissions
log "Sudoers configured in $SUDOERS_FILE_PATH. Ensure your GitHub Actions SSH user is '$APP_USER'."

# --- Final Instructions ---
log "Initial server setup script finished."
warn "--------------------------------------------------------------------------------"
warn "CRITICAL MANUAL STEPS REQUIRED:"
warn "1. SSH into your server: ssh -i \"your-key.pem\" $APP_USER@${DOMAIN_NAME_OR_IP}"
warn "2. CAREFULLY EDIT Backend .env: sudo nano $BACKEND_ENV_FILE"
warn "   - Verify/Update DATABASE_URL (current placeholder: ${DATABASE_URL_PLACEHOLDER})"
warn "   - Generate and update JWT_SECRET."
warn "   - Generate and update NEXTAUTH_SECRET in BOTH backend and frontend .env files (they must match if used for same purpose)."
warn "   - Configure actual SMTP, AWS S3 credentials (USING IAM ROLES FOR EC2 IS STRONGLY RECOMMENDED INSTEAD OF HARDCODING KEYS IN .ENV)."
warn "3. CAREFULLY EDIT Frontend .env.production: sudo nano $FRONTEND_ENV_FILE"
warn "   - Ensure NEXTAUTH_SECRET matches the one in the backend if applicable."
warn "   - Verify NEXT_PUBLIC_API_URL (current placeholder: https://$DOMAIN_NAME/api)."
warn "4. Review Nginx config: cat $NGINX_CONF_FILE. Especially SSL settings and proxy timeouts."
warn "5. Test your domain https://$DOMAIN_NAME in a browser."
warn "6. Your first deployment via GitHub Actions should build and start the applications."
warn "   The CI/CD pipeline expects to find the repository at $APP_DIR."
warn "   It will run 'npx prisma migrate deploy', so ensure DB is accessible from EC2 and $BACKEND_ENV_FILE is correct."
warn "--------------------------------------------------------------------------------"

log "Setup complete. The server should be ready for CI/CD deployments AFTER MANUAL .env CONFIGURATION." 