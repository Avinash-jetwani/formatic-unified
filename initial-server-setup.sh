#!/bin/bash
set -e

# Colors for better readability
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
RED='\\033[0;31m'
NC='\\033[0m' # No Color

# Log function
log() {
  echo -e "${GREEN}[$(date '+%Y-%m-%d %H:%M:%S')] $1${NC}"
}

error() {
  echo -e "${RED}[ERROR] $1${NC}" >&2
}

warn() {
  echo -e "${YELLOW}[WARNING] $1${NC}"
}

# --- Configuration - Adjust these variables as needed ---
APP_USER="ec2-user" # The user that will own the application files and run pm2
APP_DIR="/home/$APP_USER/formatic-unified" # Main application directory
REPO_URL="https://github.com/Avinash-jetwani/formatic-unified.git" # User's repository URL
DOMAIN_NAME="datizmo.com" # User's domain name
ADMIN_EMAIL="jetwaniavinash@gmail.com" # User's email for SSL certificate registration

# Ensure NEXTAUTH_URL and other sensitive env vars are set appropriately later
# These are placeholders - USER MUST FILL THESE ON THE SERVER
DATABASE_URL_PLACEHOLDER="postgresql://postgres:immortal1497db@formatic-dev-db.c7edc3pems97.eu-west-2.rds.amazonaws.com:5432/formatic-dev-db"
JWT_SECRET_PLACEHOLDER="p4t7w!z%C*F-JaNdRgUjXn2r5u8x/A?D(G+KbPeShVmYq3s6v9y$B&E)H@McQfTj" # GENERATED - Use this in backend .env
NEXTAUTH_SECRET_PLACEHOLDER="kZp7x!A%D*G-KaPdSgVkYp3s6v9y$B&E(H+MbQeThWmZq4t7w!z%C*F-JaNdRgUj" # GENERATED - Use this in frontend .env.production (and backend if shared)
AWS_ACCESS_KEY_ID_PLACEHOLDER="AKIAQ7KIB76C33G75FOM_EnsureThisIsCorrect_Or_Use_IAM_Role"
AWS_SECRET_ACCESS_KEY_PLACEHOLDER="3B7GDaiWrSDA3BVQh2A9JWj65yLuR3TtIa_gnFIO_EnsureThisIsCorrect_Or_Use_IAM_Role"
AWS_S3_BUCKET_PLACEHOLDER="formatic-uploads-dev" # Updated S3 bucket name
SMTP_HOST_PLACEHOLDER="your_smtp_host"
SMTP_PORT_PLACEHOLDER="587"
SMTP_USER_PLACEHOLDER="your_smtp_user"
SMTP_PASS_PLACEHOLDER="your_smtp_password"
EMAIL_FROM_PLACEHOLDER="noreply@$DOMAIN_NAME"


# --- Script Start ---
log "Starting Initial Server Setup for Datizmo (User: $APP_USER)..."

if [ "$(id -u)" != "0" ]; then
  error "This script must be run as root. Please use sudo."
  exit 1
fi

# 1. System Update and Essential Packages
log "Updating system packages and installing essential tools..."
# Commands might differ slightly for Amazon Linux (yum vs apt-get)
# Assuming an Amazon Linux 2 environment based on 'ec2-user'
if command -v yum &> /dev/null; then
    yum update -y
    yum install -y curl wget git unzip nginx # ufw is not typically used on Amazon Linux, Security Groups are preferred
elif command -v apt-get &> /dev/null; then
    apt-get update
    apt-get upgrade -y
    apt-get install -y curl wget git unzip nginx ufw
else
    error "Cannot determine package manager (yum or apt-get). Exiting."
    exit 1
fi

# 2. Install Node.js and PM2
log "Installing Node.js v18.x and PM2..."
if ! command -v node &> /dev/null; then
  # For Amazon Linux, NodeSource setup might differ slightly. Using nvm is often more robust.
  log "Installing nvm (Node Version Manager)..."
  sudo -u $APP_USER curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | sudo -u $APP_USER bash
  sudo -u $APP_USER sh -c ". /home/$APP_USER/.nvm/nvm.sh && nvm install 18 && nvm alias default 18 && nvm use default"
  log "NVM and Node.js 18 installed for user $APP_USER."
  sudo -u $APP_USER sh -c ". /home/$APP_USER/.nvm/nvm.sh && npm install -g pm2"
  log "PM2 installed globally for Node.js 18 managed by NVM."
else
  log "Node.js version $(node -v) already installed."
  if ! sudo -u $APP_USER sh -c ". /home/$APP_USER/.nvm/nvm.sh && command -v pm2" &> /dev/null; then
    sudo -u $APP_USER sh -c ". /home/$APP_USER/.nvm/nvm.sh && npm install -g pm2"
    log "PM2 installed."
  else
    log "PM2 already installed."
  fi
fi

# Ensure pm2 can start on boot
# The command generated by `pm2 startup` needs to be run as root.
PM2_STARTUP_CMD=$(sudo -u $APP_USER sh -c ". /home/$APP_USER/.nvm/nvm.sh && pm2 startup systemd -u $APP_USER --hp /home/$APP_USER | tail -n 1")
if [[ -n "$PM2_STARTUP_CMD" && "$PM2_STARTUP_CMD" != *"[PM2] Command not found"* ]]; then
  log "Running PM2 startup command: $PM2_STARTUP_CMD"
  eval "$PM2_STARTUP_CMD"
  log "Configured PM2 to start on boot for user $APP_USER."
else
  warn "Could not automatically determine PM2 startup command. Please run 'sudo -u $APP_USER pm2 startup' and execute the outputted command manually."
fi

# 3. Configure Firewall (Security Groups on EC2 are primary)
# For Amazon Linux, UFW is not standard. Firewall rules are managed via EC2 Security Groups.
log "Firewall configuration on EC2 is primarily managed by Security Groups."
log "Ensure your Security Group allows inbound traffic on Port 22 (SSH), 80 (HTTP), 443 (HTTPS)."
if command -v ufw &> /dev/null; then # If ufw was installed (e.g. on Ubuntu base for some reason)
    log "Configuring UFW (if present)..."
    ufw default deny incoming
    ufw default allow outgoing
    ufw allow ssh
    ufw allow http
    ufw allow https
    ufw --force enable
    log "UFW configured and enabled."
fi

# 4. Application Directory (already created user 'ec2-user' exists)
log "Ensuring application directory exists: $APP_DIR"
mkdir -p $APP_DIR
chown -R $APP_USER:$APP_USER $APP_DIR
chmod -R 755 $APP_DIR # User rwx, group rx, others rx

# 5. Clone Repository
log "Cloning repository from $REPO_URL into $APP_DIR..."
if [ -d "$APP_DIR/.git" ]; then
  warn "Repository already exists in $APP_DIR. Performing a git pull as $APP_USER instead of clone."
  sudo -u $APP_USER git -C $APP_DIR pull
else
  sudo -u $APP_USER git clone $REPO_URL $APP_DIR
  log "Repository cloned into $APP_DIR by user $APP_USER."
fi

# 6. Setup Backend .env file
log "Setting up backend .env file (placeholder) in $APP_DIR/backend/.env..."
BACKEND_DIR="$APP_DIR/backend"
BACKEND_ENV_FILE="$BACKEND_DIR/.env"
mkdir -p $BACKEND_DIR # Ensure backend directory exists
chown $APP_USER:$APP_USER $BACKEND_DIR

if [ -f "$BACKEND_ENV_FILE" ]; then
  warn "Backend .env file already exists. Contents will be preserved if possible, but ensure it has all necessary variables."
  # Optionally, append missing keys or notify user to check thoroughly.
else
  sudo -u $APP_USER touch $BACKEND_ENV_FILE
fi
# Ensure the file has the correct ownership and basic permissions before writing
chown $APP_USER:$APP_USER $BACKEND_ENV_FILE
chmod 600 $BACKEND_ENV_FILE # Restrict permissions (user rw, group none, others none)

# Write placeholders - USER MUST VERIFY/UPDATE THESE MANUALLY
sudo -u $APP_USER cat > $BACKEND_ENV_FILE <<EOL
# --- Database Configuration (MUST BE VERIFIED/UPDATED BY USER) ---
DATABASE_URL=${DATABASE_URL_PLACEHOLDER}

# --- JWT Configuration (MUST BE GENERATED & UPDATED BY USER) ---
JWT_SECRET=${JWT_SECRET_PLACEHOLDER}
JWT_EXPIRATION=1d

# --- Email Configuration (MUST BE UPDATED BY USER) ---
SMTP_HOST=${SMTP_HOST_PLACEHOLDER}
SMTP_PORT=${SMTP_PORT_PLACEHOLDER}
SMTP_USER=${SMTP_USER_PLACEHOLDER}
SMTP_PASS=${SMTP_PASS_PLACEHOLDER}
EMAIL_FROM=${EMAIL_FROM_PLACEHOLDER}

# --- S3 Configuration for File Uploads (MUST BE VERIFIED/UPDATED BY USER - CONSIDER IAM ROLES FOR EC2 INSTEAD OF HARDCODED KEYS) ---
AWS_REGION=us-east-1 # Or your preferred region
AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID_PLACEHOLDER}
AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY_PLACEHOLDER}
AWS_S3_BUCKET=${AWS_S3_BUCKET_PLACEHOLDER}

# --- Application Settings ---
NODE_ENV=production
PORT=3001 # Backend listens on this port
# FRONTEND_URL=https://$DOMAIN_NAME # If needed by backend for CORS etc.
EOL
warn "IMPORTANT: Placeholder backend .env file written to $BACKEND_ENV_FILE."
warn "YOU MUST SSH INTO THE SERVER AND MANUALLY EDIT THIS FILE with your actual production credentials (Database, JWT, Email, S3 etc.)."

# 7. Setup Frontend .env.production file
log "Setting up frontend .env.production file (placeholder) in $APP_DIR/frontend/.env.production..."
FRONTEND_DIR="$APP_DIR/frontend"
FRONTEND_ENV_FILE="$FRONTEND_DIR/.env.production"
mkdir -p $FRONTEND_DIR # Ensure frontend directory exists
chown $APP_USER:$APP_USER $FRONTEND_DIR

if [ -f "$FRONTEND_ENV_FILE" ]; then
  warn "Frontend .env.production file already exists. Contents will be preserved if possible."
else
  sudo -u $APP_USER touch $FRONTEND_ENV_FILE
fi
chown $APP_USER:$APP_USER $FRONTEND_ENV_FILE
chmod 600 $FRONTEND_ENV_FILE

sudo -u $APP_USER cat > $FRONTEND_ENV_FILE <<EOL
# --- Frontend Configuration (MUST BE VERIFIED/UPDATED BY USER) ---
NEXT_PUBLIC_API_URL=https://$DOMAIN_NAME/api
NEXTAUTH_URL=https://$DOMAIN_NAME
NEXTAUTH_SECRET=${NEXTAUTH_SECRET_PLACEHOLDER} # (MUST BE GENERATED & UPDATED BY USER - SAME AS JWT_SECRET OR A DEDICATED ONE)

# Add any other NEXT_PUBLIC_ variables your frontend needs
# NEXT_PUBLIC_SOME_CONFIG_VAR=some_value
EOL
warn "IMPORTANT: Placeholder frontend .env.production file written to $FRONTEND_ENV_FILE."
warn "YOU MUST SSH INTO THE SERVER AND MANUALLY EDIT THIS FILE (especially NEXTAUTH_SECRET)."

# 8. Install Dependencies (Initial - CI/CD will handle subsequent updates and builds)
log "Performing initial dependency installation for basic setup (as $APP_USER)..."
# Backend
if [ -f "$BACKEND_DIR/package.json" ]; then
  log "Installing backend dependencies (production only)..."
  sudo -u $APP_USER sh -c "cd $BACKEND_DIR && . /home/$APP_USER/.nvm/nvm.sh && npm ci --omit=dev"
  log "Generating Prisma client for backend..."
  sudo -u $APP_USER sh -c "cd $BACKEND_DIR && . /home/$APP_USER/.nvm/nvm.sh && npx prisma generate"
else
  warn "No package.json found in $BACKEND_DIR. Skipping backend dependency install."
fi
# Frontend
if [ -f "$FRONTEND_DIR/package.json" ]; then
  log "Installing frontend dependencies (production only)..."
  sudo -u $APP_USER sh -c "cd $FRONTEND_DIR && . /home/$APP_USER/.nvm/nvm.sh && npm ci --omit=dev"
else
  warn "No package.json found in $FRONTEND_DIR. Skipping frontend dependency install."
fi
warn "Initial builds are skipped. The CI/CD pipeline will handle application builds and provide artifacts."
warn "Initial 'npx prisma migrate deploy' will be run by the first CI/CD deployment."

# 9. Setup Nginx Configuration
log "Setting up Nginx configuration for $DOMAIN_NAME..."
# For Amazon Linux, Nginx config is often in /etc/nginx/conf.d/
NGINX_CONF_DIR="/etc/nginx/conf.d"
NGINX_CONF_FILE="$NGINX_CONF_DIR/$DOMAIN_NAME.conf"

# Create a basic Nginx configuration. Certbot will modify this for SSL.
cat > "$NGINX_CONF_FILE" <<EOL
server {
    listen 80;
    server_name $DOMAIN_NAME www.$DOMAIN_NAME;

    # Serve Let's Encrypt challenge files
    location /.well-known/acme-challenge/ {
        root /var/www/html; # Default for Amazon Linux, or use /var/www/certbot
    }

    location / {
        # This block will be updated by Certbot or later for proxying
        root /var/www/html;
        index index.html index.htm;
    }
}
EOL

log "Testing Nginx configuration..."
nginx -t
if [ $? -eq 0 ]; then
  log "Nginx configuration test successful. Reloading Nginx."
  systemctl reload nginx
else
  error "Nginx configuration test failed. Please check $NGINX_CONF_FILE. Nginx default page might be shown."
  # Don't exit, allow certbot to try and fix
fi

# 10. Setup SSL with Certbot
log "Setting up SSL certificate using Certbot..."
# Install Certbot - EPEL repo might be needed for Amazon Linux 2
if command -v yum &> /dev/null; then
    amazon-linux-extras install epel -y
    yum install -y certbot python3-certbot-nginx # Use python3-certbot-nginx for AL2
fi

# Create /var/www/certbot directory if it doesn't exist (or use /var/www/html as per Nginx conf)
WEBROOT_PATH="/var/www/html" # Matching the Nginx config for challenges
mkdir -p $WEBROOT_PATH
chown nginx:nginx $WEBROOT_PATH # Nginx user

log "Requesting SSL certificate for $DOMAIN_NAME (using webroot $WEBROOT_PATH)..."
certbot certonly --webroot -w $WEBROOT_PATH -d $DOMAIN_NAME -d www.$DOMAIN_NAME --non-interactive --agree-tos -m $ADMIN_EMAIL --deploy-hook "systemctl reload nginx"

if [ $? -eq 0 ]; then
  log "SSL certificate obtained successfully."
  # Now update Nginx config to use SSL and proxy to applications
  log "Updating Nginx configuration to use SSL and proxy to Node.js applications..."
cat > "$NGINX_CONF_FILE" <<EOL
server {
    listen 80;
    server_name $DOMAIN_NAME www.$DOMAIN_NAME;

    location /.well-known/acme-challenge/ {
        root $WEBROOT_PATH;
    }

    location / {
        return 301 https://\\\$host\\\$request_uri;
    }
}

server {
    listen 443 ssl http2;
    server_name $DOMAIN_NAME www.$DOMAIN_NAME;

    ssl_certificate /etc/letsencrypt/live/$DOMAIN_NAME/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/$DOMAIN_NAME/privkey.pem;
    # Using recommended ciphers and protocols by Certbot/Mozilla
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 1d;
    ssl_session_tickets off;

    # Recommended: ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # Generate if not present: openssl dhparam -out /etc/letsencrypt/ssl-dhparams.pem 2048
    # Check if ssl-dhparams.pem exists, if not, Certbot might handle this or it should be generated.
    if [ -f /etc/letsencrypt/ssl-dhparams.pem ]; then
        ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
    fi

    # HSTS
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;
    # Other Security Headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    client_max_body_size 50M; # For file uploads, adjust as needed

    location / {
        proxy_pass http://localhost:3000; # Frontend (Next.js running on port 3000)
        proxy_http_version 1.1;
        proxy_set_header Upgrade \\\$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host \\\$host;
        proxy_set_header X-Real-IP \\\$remote_addr;
        proxy_set_header X-Forwarded-For \\\$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \\\$scheme;
        proxy_cache_bypass \\\$http_upgrade;
        proxy_read_timeout 300s; # Increase timeout for potentially long requests
        proxy_send_timeout 300s;
    }

    location /api {
        proxy_pass http://localhost:3001; # Backend (NestJS running on port 3001)
        proxy_http_version 1.1;
        proxy_set_header Upgrade \\\$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host \\\$host;
        proxy_set_header X-Real-IP \\\$remote_addr;
        proxy_set_header X-Forwarded-For \\\$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \\\$scheme;
        proxy_cache_bypass \\\$http_upgrade;
        proxy_read_timeout 300s;
        proxy_send_timeout 300s;
    }
    
    location /socket.io {
        proxy_pass http://localhost:3001; # Backend WebSocket
        proxy_http_version 1.1;
        proxy_set_header Upgrade \\\$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \\\$host;
        proxy_cache_bypass \\\$http_upgrade;
    }
}
EOL
  log "Testing final Nginx configuration..."
  nginx -t && systemctl reload nginx
  if [ $? -ne 0 ]; then error "Final Nginx configuration test failed. Please check $NGINX_CONF_FILE"; fi
else
  error "Certbot failed to obtain SSL certificate. Check logs at /var/log/letsencrypt/"
  warn "You might need to manually adjust Nginx ($NGINX_CONF_FILE) and run certbot again."
  warn "Consider using 'certbot --nginx' if webroot fails and Nginx is properly serving HTTP for the domain."
fi

# 11. Setup PM2 Ecosystem File (Optional but Recommended)
ECOSYSTEM_FILE_PATH="$APP_DIR/ecosystem.config.js"
log "Creating PM2 ecosystem file at $ECOSYSTEM_FILE_PATH (as $APP_USER)..."

sudo -u $APP_USER cat > $ECOSYSTEM_FILE_PATH <<EOL
module.exports = {
  apps : [{
    name   : "frontend",
    script : "npm",
    args   : "run start", // Assumes 'start': 'next start -p 3000' in frontend/package.json
    cwd    : "$APP_DIR/frontend",
    watch  : false,
    instances: 1,
    exec_mode: 'cluster', // Or 'fork'
    env_production: {
      NODE_ENV: "production",
      PORT: 3000 // Next.js listens on this port
    }
  },{
    name   : "backend",
    script : "dist/main.js", // Path to NestJS main entry point from backend directory
    cwd    : "$APP_DIR/backend",
    watch  : false,
    instances: 1,
    exec_mode: 'cluster', // Or 'fork'
    env_production: {
      NODE_ENV: "production",
      PORT: 3001 // NestJS listens on this port (must match .env and Nginx)
    }
  }]
}
EOL
chown $APP_USER:$APP_USER $ECOSYSTEM_FILE_PATH
log "PM2 ecosystem file created. The CI/CD pipeline can use this via: sudo -u $APP_USER sh -c '. /home/$APP_USER/.nvm/nvm.sh && pm2 reload $ECOSYSTEM_FILE_PATH --env production'"

# 12. Configure sudo for deployment user ($APP_USER)
SUDOERS_FILE_PATH="/etc/sudoers.d/91-$APP_USER-deploy"
log "Configuring passwordless sudo for $APP_USER for PM2 and Nginx reload..."
# Get full path to pm2 via nvm for the APP_USER
PM2_PATH_CMD="sudo -u $APP_USER sh -c '. /home/$APP_USER/.nvm/nvm.sh && which pm2'"
PM2_FULL_PATH=$(eval $PM2_PATH_CMD)

if [ -z "$PM2_FULL_PATH" ]; then
    warn "Could not determine full path to pm2 for sudoers. Please add manually."
    PM2_FULL_PATH="/home/$APP_USER/.nvm/versions/node/$(sudo -u $APP_USER sh -c '. /home/$APP_USER/.nvm/nvm.sh && node -v')/bin/pm2" # Fallback guess
fi

cat > "$SUDOERS_FILE_PATH" <<EOL
# Allow $APP_USER to manage PM2 services and reload Nginx without a password
$APP_USER ALL=(ALL) NOPASSWD: $PM2_FULL_PATH, /bin/systemctl reload nginx
EOL
chmod 0440 "$SUDOERS_FILE_PATH" # Secure permissions
log "Sudoers configured in $SUDOERS_FILE_PATH. Ensure your GitHub Actions SSH user is '$APP_USER'."

# --- Final Instructions ---
log "Initial server setup script finished."
warn "--------------------------------------------------------------------------------"
warn "CRITICAL MANUAL STEPS REQUIRED:"
warn "1. SSH into your server: ssh -i \"your-key.pem\" $APP_USER@${DOMAIN_NAME_OR_IP}"
warn "2. CAREFULLY EDIT Backend .env: sudo nano $BACKEND_ENV_FILE"
warn "   - Verify/Update DATABASE_URL (current placeholder: ${DATABASE_URL_PLACEHOLDER})"
warn "   - Generate and update JWT_SECRET."
warn "   - Generate and update NEXTAUTH_SECRET in BOTH backend and frontend .env files (they must match if used for same purpose)."
warn "   - Configure actual SMTP, AWS S3 credentials (USING IAM ROLES FOR EC2 IS STRONGLY RECOMMENDED INSTEAD OF HARDCODING KEYS IN .ENV)."
warn "3. CAREFULLY EDIT Frontend .env.production: sudo nano $FRONTEND_ENV_FILE"
warn "   - Ensure NEXTAUTH_SECRET matches the one in the backend if applicable."
warn "   - Verify NEXT_PUBLIC_API_URL (current placeholder: https://$DOMAIN_NAME/api)."
warn "4. Review Nginx config: cat $NGINX_CONF_FILE. Especially SSL settings and proxy timeouts."
warn "5. Test your domain https://$DOMAIN_NAME in a browser."
warn "6. Your first deployment via GitHub Actions should build and start the applications."
warn "   The CI/CD pipeline expects to find the repository at $APP_DIR."
warn "   It will run 'npx prisma migrate deploy', so ensure DB is accessible from EC2 and $BACKEND_ENV_FILE is correct."
warn "--------------------------------------------------------------------------------"

log "Setup complete. The server should be ready for CI/CD deployments AFTER MANUAL .env CONFIGURATION." 